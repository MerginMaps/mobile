name: Mergin Maps delivery
on:
  workflow_run:
    types:
      - "completed"
    # Unfortunately we can't specify multiple workflows after which this workflow is triggered. If we specify
    # multiple workflows the first that finishes triggers this workflow, so we pick the "longest". Linux sometimes takes
    # longer to build, but we ship Windows, so it has higher priority.
    workflows:
      - "win64 Build"

permissions:
  actions: read
  pull-requests: write

jobs:
  comment_on_pr:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Find Artifacts and Format Comment
        id: artifact_finder
        uses: actions/github-script@v7
        with:
          # This script finds the artifacts from the required dependency workflows
          # that ran on the same commit (head_sha) as this PR.
          script: |
            const buildWorkflowNames = ['macOS Build', 'linux Build', 'win64 Build', 'Android Build', 'iOS Build'];
            const headSha = context.payload.pull_request.head.sha;
            let commentBody = '## ðŸ“¦ Build Artifacts Ready\n\n';
            let artifactsFound = false;
            
            for (const workflowName of buildWorkflowNames) {
              // 1. Find the latest successful run for the specific workflow and commit SHA
              const runsResponse = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: headSha,
                status: 'success',
                per_page: 10
              });
            
              // Filter to find the run matching the exact workflow name
              const latestRun = runsResponse.data.workflow_runs.find(run => 
                run.name === workflowName && run.conclusion === 'success'
              );
            
              if (!latestRun) {
                console.log(`Could not find a successful run for workflow: ${workflowName}`);
                commentBody += `- :x: **${workflowName}**: Build not yet complete or failed.\n`;
                continue;
              }
            
              // 2. List artifacts for that specific run
              const artifactsResponse = await github.rest.actions.listWorkflowRunArtifacts({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: latestRun.id,
              });
            
              const artifacts = artifactsResponse.data.artifacts;
            
              if (artifacts.length > 0) {
                commentBody += `### ${workflowName} (Run #${latestRun.id})\n`;
            
                for (const artifact of artifacts) {
                  const apiDownloadUrl = `https://api.github.com/repos/${context.repo.owner}/${context.repo.repo}/actions/artifacts/${artifact.id}/zip`;
            
                  commentBody += `- [ðŸ“¥ **${artifact.name}**](${apiDownloadUrl}) (Expires: ${new Date(artifact.expires_at).toLocaleDateString()})\n`;
                  artifactsFound = true;
                }
              }
            }
            
            if (artifactsFound) {
                // Set the output for the next step
                core.setOutput('comment_body', commentBody);
            } else {
                core.setOutput('comment_body', 'No artifacts found for this PR commit.');
            }

      - name: Update Comment
        if: steps.artifact_finder.outputs.comment_body != 'No artifacts found for this PR commit.'
        uses: peter-evans/create-or-update-comment@v5
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: ${{ steps.artifact_finder.outputs.comment_body }}